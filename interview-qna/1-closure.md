## Q. 클로저에 대해서 설명해주세요.

## A.

### 정의

함수가 선언될 때의 스코프를 기억하여, 함수가 생성된 이후에도 그 스코프에 접근할 수 있는 기능을 말합니다.
(자신이 생성될때의 환경을 기억하는 함수)

**클로저 예시 코드**

```ts
let saveNumber = 1; //어디서나 접근가능

function increment() {
  //클로저: 함수 안쪽에서 함수가 만들어질때 그 함수 바깥함수의 변수에 접근하게 되면
  //접근한 변수를 클로저라는 공간에 저장, 호출되었을 때 저장된 값을 유지하면서 반환
  let saveNumber = 1;

  return function innerFunction() {
    return saveNumber++;
  };
}

const inc = increment();
console.log(inc()); // 1
console.log(inc()); // 2

saveNumber = 200;

console.log(inc()); // 3
```

`innerFunction`은 `increment`함수 내부에 정의되어 있는데, `innerFunction`은 자신이 생성된 스코프인 `increment`의 스코프를 기억하고 `increment` 호출이 완료된 이후여도 그 스코프에 접근할 수 있습니다.

### 클로저는 언제 활용되나요?

클로저는 변수와 함수의 접근 범위를 제어하고 특정 데이터와 상태를 안전하게 변경하고 유지하기 위해 자주 활용됩니다.

1. 클로저는 외부에서 접근할 수 없는 비공개 변수와 함수를 만들 수 있습니다. 따라서 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태변경을 허용하기 위해 사용한다.

2. 비동기 작업에 활용됩니다. 클로저는 비동기 작업에서 이전의 실행 컨텍스트를 유지해야 할 때 유용합니다. 콜백 함수가 비동기적으로 실행될 때 클로저를 사용하면 함수 실행 시점의 변수를 참조할 수 있습니다.

3. 모듈 패턴을 구현하는 데 활용됩니다. 모듈 패턴은 특정 기능을 캡슐화하고, 외부에 공개하고자 하는 부분만 선택적으로 노출하여 코드의 응집력을 높이고, 유지보수성을 향상시키는 패턴입니다. 클로저를 활용하면 필요한 함수와 데이터만 외부로 노출함으로써 모듈 패턴을 쉽게 구현할 수 있습니다.
